//Timer 1 Input capture: it is used to measure the time between the raising edge of the input and the falling edge of the input, which is the echoPin. In this way we are able to measure the distances.
//A LED turns on if the distance is smaller than 10 cm. 

//Libraries
#include <Arduino.h>

//Variables
volatile uint16_t Capt1, Capt2;//VARIABLES TO HOLD TIMESTAMPS
volatile uint8_t flag = 0; //CAPTURE FLAG
const uint32_t speed_sound = 34300; //Speed of sound in cm/s
uint32_t dist; //I multiply the counts firstly for the speed of sound and then in
uint32_t dist2;
int j = 0;

//define the pin numbers
const int trigPin = PB1;
const int echoPin = PB0; //It is the port used as input for input capture
const int led = PD2;

/*--------------------------------------------------------------------------------------------------
MAIN FUNCTION
---------------------------------------------------------------------------------------------------*/
void setup(){
  
  
  Serial.begin(115200);
 //Set echopin as input and enable the pull-up
  DDRB &= ~(1 << echoPin); //Input
  PORTB |= (1 << echoPin); //Enable pull-up resistors

  //Set trigpin as output
  DDRB |= (1 << trigPin); //Output
  PORTB &= ~(1 << trigPin);  //Set the output to zero

  //Set led as output
  DDRD |= (1 << led);
  PORTD &= ~(1 << led);

  
  //Interrupts settings
  TCCR1A = 0; //Disable compare interrupts
  TCCR1B = 0; 
  TCNT1=0; //SETTING INTIAL TIMER VALUE
  
  TCCR1B|=(1<<ICES1); //SETTING FIRST CAPTURE ON RISING EDGE 
  TIMSK1|=(1<<ICIE1); //ENABLING INPUT CAPTURE
  TIFR1 &= ~(1 << ICF1); //Clear the flag 
  TCCR1B|=(1<<CS10);
  TCCR1B &= ~(1<<CS12);
  TCCR1B &= ~(1<<CS11);//STARTING TIMER WITH NO PRESCALER 
  
  sei(); //ENABLING GLOBAL INTERRUPTS
  
  //I send the first input and then I send it again only if the the flag is equal to 2, that means that the echopin has been received
  PORTB |= (1 << trigPin);
  _delay_us(10);
  PORTB &= ~(1 << trigPin);
 
  
  }
  
void loop(){
 
    //calculate the distance if all timestamps are captured
    
     if (flag == 2)
    {
      dist =(Capt2 - Capt1)*speed_sound/2;
      dist2 = dist/F_CPU;
      
      Serial.println(dist2);
      
      //Turn on the LED if the distance is below 10 cm
      if (dist2 < 10){
        PORTD |= (1 << led);
        }
    else {
      PORTD &= ~(1 << led);
      }
      
      flag = 0; //CLEARING FLAGS
      
      TIMSK1|=(1<<ICIE1); //ENABLING INPUT CAPTURE INTERRUPTS
      TCNT1 = 0;
      
      PORTB |= (1 << trigPin);
      _delay_us(10);
      PORTB &= ~(1 << trigPin);
      TCNT1=0;


      
    }
  
  }

/*--------------------------------------------------------------------------------------------------
CAPTURE ISR
---------------------------------------------------------------------------------------------------*/
ISR(TIMER1_CAPT_vect)
{

//PORTD |= (1 << led);
if (flag == 0)
{
  Capt1 = ICR1; //SAVING CAPTURED TIMESTAMP
  TCCR1B &=~(1<<ICES1); //CHANGE CAPTURE ON FALLING EDGE
  

}
if (flag == 1)
{
  Capt2 = ICR1; //SAVING CAPTURED TIMESTAMP
  TCCR1B|=(1<<ICES1); //CHANGING CAPTURE ON RISING EDGE
  
  TIFR1 &= ~(1 << ICF1); //Clear the flag
}
 flag = flag + 1;
}
